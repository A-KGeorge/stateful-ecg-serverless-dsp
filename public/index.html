<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ü´Ä ECG Monitor - Stateful Serverless DSP Demo</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
        padding: 20px;
        min-height: 100vh;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
      }

      h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
      }

      .subtitle {
        font-size: 1.1rem;
        opacity: 0.9;
      }

      .dashboard {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }

      .card {
        background: white;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .card-header {
        font-size: 0.9rem;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 10px;
      }

      .card-value {
        font-size: 3rem;
        font-weight: bold;
        color: #667eea;
      }

      .card-unit {
        font-size: 1.2rem;
        color: #999;
        margin-left: 10px;
      }

      .status {
        display: inline-block;
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: 600;
        margin-top: 10px;
      }

      .status.normal {
        background: #d4edda;
        color: #155724;
      }

      .status.warning {
        background: #fff3cd;
        color: #856404;
      }

      .status.critical {
        background: #f8d7da;
        color: #721c24;
      }

      .waveform-container {
        background: white;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }

      canvas {
        width: 100%;
        height: 300px;
        display: block;
        background: #000;
        border-radius: 8px;
      }

      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 15px;
      }

      .metric {
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
        border-left: 4px solid #667eea;
      }

      .metric-label {
        font-size: 0.85rem;
        color: #666;
        margin-bottom: 5px;
      }

      .metric-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: #333;
      }

      .alerts {
        background: white;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .alert {
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .alert.info {
        background: #d1ecf1;
        border-left: 4px solid #0c5460;
      }

      .alert.warning {
        background: #fff3cd;
        border-left: 4px solid #856404;
      }

      .alert.critical {
        background: #f8d7da;
        border-left: 4px solid #721c24;
      }

      .alert-icon {
        font-size: 1.5rem;
      }

      .alert-text {
        flex: 1;
      }

      .alert-time {
        font-size: 0.85rem;
        color: #666;
      }

      .footer {
        text-align: center;
        color: white;
        margin-top: 30px;
        opacity: 0.8;
      }

      .pulse {
        animation: pulse 1s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .connected {
        display: inline-block;
        width: 10px;
        height: 10px;
        background: #28a745;
        border-radius: 50%;
        margin-right: 5px;
        animation: pulse 2s ease-in-out infinite;
      }

      .disconnected {
        display: inline-block;
        width: 10px;
        height: 10px;
        background: #dc3545;
        border-radius: 50%;
        margin-right: 5px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>ü´Ä ECG Monitor</h1>
        <p class="subtitle">
          <span id="connection-status" class="disconnected"></span>
          Stateful Serverless DSP Demo - Pan-Tompkins QRS Detection
        </p>
      </header>

      <div class="dashboard">
        <div class="card">
          <div class="card-header">Heart Rate</div>
          <div>
            <span class="card-value" id="heart-rate">--</span>
            <span class="card-unit">BPM</span>
          </div>
          <div class="status normal" id="hr-status">Normal Sinus Rhythm</div>
        </div>

        <div class="card">
          <div class="card-header">Heart Rate Variability</div>
          <div>
            <span class="card-value" id="hrv">--</span>
            <span class="card-unit">ms</span>
          </div>
        </div>

        <div class="card">
          <div class="card-header">Peaks Detected</div>
          <div>
            <span class="card-value" id="peak-count">0</span>
            <span class="card-unit">total</span>
          </div>
        </div>

        <div class="card">
          <div class="card-header">Processing Latency</div>
          <div>
            <span class="card-value" id="latency">--</span>
            <span class="card-unit">ms</span>
          </div>
        </div>
      </div>

      <div class="waveform-container">
        <div class="card-header">Real-Time ECG Waveform</div>
        <canvas id="ecg-canvas"></canvas>
        <div class="metrics">
          <div class="metric">
            <div class="metric-label">Sensor ID</div>
            <div class="metric-value" id="sensor-id">Waiting...</div>
          </div>
          <div class="metric">
            <div class="metric-label">Chunk Index</div>
            <div class="metric-value" id="chunk-index">-</div>
          </div>
          <div class="metric">
            <div class="metric-label">State Size</div>
            <div class="metric-value" id="state-size">-- bytes</div>
          </div>
          <div class="metric">
            <div class="metric-label">Samples Processed</div>
            <div class="metric-value" id="samples-processed">0</div>
          </div>
        </div>
      </div>

      <div class="alerts">
        <div class="card-header">Arrhythmia Alerts</div>
        <div id="alerts-container">
          <div class="alert info">
            <span class="alert-icon">‚ÑπÔ∏è</span>
            <div class="alert-text">
              <div><strong>System Ready</strong></div>
              <div class="alert-time">Waiting for ECG data...</div>
            </div>
          </div>
        </div>
      </div>

      <footer class="footer">
        <p>
          <strong>Architecture:</strong> Serverless Worker ‚Üí Redis State Store ‚Üí
          Real-Time Dashboard
        </p>
        <p>
          Demonstrating stateful DSP across ephemeral serverless invocations
        </p>
        <p style="margin-top: 10px; opacity: 0.7">
          Built with ‚ù§Ô∏è using dspx library | State size: 758 bytes (TOON format)
        </p>
      </footer>
    </div>

    <script>
      // Canvas setup
      const canvas = document.getElementById("ecg-canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = canvas.offsetWidth;
      canvas.height = 300;

      // ECG waveform state
      let ecgData = [];
      let peakIndices = [];
      let maxDataPoints = 1800; // 5 seconds at 360 Hz
      let totalPeaks = 0;
      let totalSamples = 0;
      let lastResultTimestamp = 0;
      let isDemoMode = false;
      let startTime = 0; // Track absolute start time for axis labeling

      // WebSocket connection for real-time updates
      let ws;
      let reconnectInterval;

      // Throttling: Queue updates and process them at 1 per second (real-time speed)
      let updateQueue = [];
      let isProcessingQueue = false;
      let lastUpdate = 0;
      const UPDATE_INTERVAL = 1000; // 1 second per chunk (real-time playback)

      function connectWebSocket() {
        const wsProtocol =
          window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${wsProtocol}//${window.location.host}`;

        console.log("Connecting to WebSocket:", wsUrl);
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          console.log("‚úÖ WebSocket connected");
          document.getElementById("connection-status").className = "connected";
          if (reconnectInterval) {
            clearInterval(reconnectInterval);
            reconnectInterval = null;
          }
        };

        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);

          if (data.error) {
            isDemoMode = true;
            document.getElementById("connection-status").className =
              "disconnected";
          } else {
            // Real data received!
            isDemoMode = false;
            document.getElementById("connection-status").className =
              "connected";

            // FIX: Push to queue instead of updating directly
            updateQueue.push(data);

            // Start the queue processor if it's not running
            if (!isProcessingQueue) {
              processUpdateQueue();
            }
          }
        };

        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
        };

        ws.onclose = () => {
          console.log("‚ùå WebSocket disconnected");
          document.getElementById("connection-status").className =
            "disconnected";
          isDemoMode = true;

          // Attempt reconnection
          if (!reconnectInterval) {
            reconnectInterval = setInterval(() => {
              console.log("Attempting to reconnect...");
              connectWebSocket();
            }, 3000);
          }
        };
      }

      function processUpdateQueue() {
        if (updateQueue.length === 0) {
          isProcessingQueue = false;
          return;
        }

        isProcessingQueue = true;
        const now = Date.now();
        const timeSinceLastUpdate = now - lastUpdate;

        // If enough time has passed, process next update
        if (timeSinceLastUpdate >= UPDATE_INTERVAL || lastUpdate === 0) {
          const data = updateQueue.shift();
          updateDashboard(data);
          lastUpdate = now;

          // Schedule next update
          setTimeout(processUpdateQueue, UPDATE_INTERVAL);
        } else {
          // Wait for remaining time
          setTimeout(processUpdateQueue, UPDATE_INTERVAL - timeSinceLastUpdate);
        }
      }

      function updateDashboard(data) {
        document.getElementById("connection-status").className = "connected";

        // Update metrics
        document.getElementById("heart-rate").textContent = data.bpm || "--";
        document.getElementById("hrv").textContent = data.hrv || "--";
        document.getElementById("latency").textContent =
          data.processingTime || "--";
        document.getElementById("sensor-id").textContent =
          data.sensorId || "Unknown";
        document.getElementById("chunk-index").textContent =
          data.chunkIndex || "-";
        document.getElementById("state-size").textContent = "758";

        // Update peak count
        totalPeaks += data.peaks || 0;
        totalSamples += 360;
        document.getElementById("peak-count").textContent = totalPeaks;
        document.getElementById("samples-processed").textContent =
          totalSamples.toLocaleString();

        // Log queue status
        if (updateQueue.length > 10) {
          console.log(
            `üìä Queue: ${updateQueue.length} chunks buffered (playing at real-time speed)`
          );
        }

        // Update HR status
        const hrStatus = document.getElementById("hr-status");
        if (data.arrhythmia && !data.arrhythmia.normal) {
          hrStatus.className = "status warning";
          hrStatus.textContent = "Arrhythmia Detected";
        } else {
          hrStatus.className = "status normal";
          hrStatus.textContent = "Normal Sinus Rhythm";
        }

        // Add alerts
        if (
          data.arrhythmia &&
          data.arrhythmia.alerts &&
          data.arrhythmia.alerts.length > 0
        ) {
          const alertsContainer = document.getElementById("alerts-container");
          data.arrhythmia.alerts.forEach((alert) => {
            const alertDiv = document.createElement("div");
            alertDiv.className = `alert ${alert.severity}`;
            alertDiv.innerHTML = `
                        <span class="alert-icon">${
                          alert.severity === "critical" ? "üö®" : "‚ö†Ô∏è"
                        }</span>
                        <div class="alert-text">
                            <div><strong>${alert.type.toUpperCase()}</strong></div>
                            <div>${alert.message}</div>
                        </div>
                        <div class="alert-time">${new Date().toLocaleTimeString()}</div>
                    `;
            alertsContainer.insertBefore(alertDiv, alertsContainer.firstChild);

            // Keep only last 5 alerts
            if (alertsContainer.children.length > 5) {
              alertsContainer.removeChild(alertsContainer.lastChild);
            }
          });
        }

        // Update waveform with real ECG samples
        if (data.samples && Array.isArray(data.samples)) {
          updateWaveform(data.samples, data.peakIndices || []);
        }
      }

      function updateWaveform(samples, peaks) {
        // Initialize start time on first data
        if (ecgData.length === 0 && startTime === 0) {
          startTime = totalSamples / 360; // Calculate absolute start time in seconds
        }

        // Add new samples to buffer
        ecgData.push(...samples);
        if (ecgData.length > maxDataPoints) {
          const removed = ecgData.length - maxDataPoints;
          ecgData = ecgData.slice(-maxDataPoints);
          startTime += removed / 360; // Update start time as we remove old data
        }

        // Draw waveform
        drawWaveform();
      }

      function drawWaveform() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (ecgData.length === 0) {
          // Draw placeholder text
          ctx.fillStyle = "#666";
          ctx.font = "20px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(
            isDemoMode
              ? "No data in Redis - Start worker and run ingestion"
              : "Waiting for ECG data...",
            canvas.width / 2,
            canvas.height / 2 - 10
          );
          if (isDemoMode) {
            ctx.font = "14px sans-serif";
            ctx.fillText(
              "Terminal 1: npm run worker | Terminal 2: npm run ingest",
              canvas.width / 2,
              canvas.height / 2 + 20
            );
          }
          return;
        }

        // Define margins for axes
        const margin = { top: 20, right: 20, bottom: 40, left: 60 };
        const plotWidth = canvas.width - margin.left - margin.right;
        const plotHeight = canvas.height - margin.top - margin.bottom;

        // Draw grid
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 1;
        for (let i = 0; i < plotWidth; i += 50) {
          ctx.beginPath();
          ctx.moveTo(margin.left + i, margin.top);
          ctx.lineTo(margin.left + i, margin.top + plotHeight);
          ctx.stroke();
        }
        for (let i = 0; i < plotHeight; i += 50) {
          ctx.beginPath();
          ctx.moveTo(margin.left, margin.top + i);
          ctx.lineTo(margin.left + plotWidth, margin.top + i);
          ctx.stroke();
        }

        // Calculate scale
        const minVal = Math.min(...ecgData);
        const maxVal = Math.max(...ecgData);
        const range = maxVal - minVal;
        const scale = plotHeight / range;

        // Draw axes
        ctx.strokeStyle = "#666";
        ctx.lineWidth = 2;

        // Y-axis
        ctx.beginPath();
        ctx.moveTo(margin.left, margin.top);
        ctx.lineTo(margin.left, margin.top + plotHeight);
        ctx.stroke();

        // X-axis
        ctx.beginPath();
        ctx.moveTo(margin.left, margin.top + plotHeight);
        ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
        ctx.stroke();

        // Y-axis labels (amplitude)
        ctx.fillStyle = "#999";
        ctx.font = "12px sans-serif";
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";

        const numYTicks = 5;
        for (let i = 0; i <= numYTicks; i++) {
          const value = minVal + (range * i) / numYTicks;
          const y = margin.top + plotHeight - (i * plotHeight) / numYTicks;
          ctx.fillText(value.toFixed(2), margin.left - 10, y);
        }

        // Y-axis label
        ctx.save();
        ctx.translate(15, canvas.height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = "center";
        ctx.fillStyle = "#aaa";
        ctx.font = "14px sans-serif";
        ctx.fillText("Amplitude (mV)", 0, 0);
        ctx.restore();

        // X-axis labels (time in seconds)
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillStyle = "#999";

        const durationSeconds = ecgData.length / 360; // 360 Hz sampling rate
        const endTime = startTime + durationSeconds; // Absolute end time
        const numXTicks = 6;
        for (let i = 0; i <= numXTicks; i++) {
          const time = startTime + (durationSeconds * i) / numXTicks;
          const x = margin.left + (i * plotWidth) / numXTicks;
          ctx.fillText(time.toFixed(1) + "s", x, margin.top + plotHeight + 5);
        }

        // X-axis label
        ctx.fillStyle = "#aaa";
        ctx.font = "14px sans-serif";
        ctx.fillText("Time (seconds)", canvas.width / 2, canvas.height - 5);

        // Draw ECG waveform
        ctx.strokeStyle = "#0f0";
        ctx.lineWidth = 2;
        ctx.beginPath();

        for (let i = 0; i < ecgData.length; i++) {
          const x = margin.left + (i / ecgData.length) * plotWidth;
          const y = margin.top + plotHeight - (ecgData[i] - minVal) * scale;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();

        // Draw peak markers
        ctx.fillStyle = "#f00";
        peakIndices.forEach((peakIdx) => {
          if (peakIdx < ecgData.length) {
            const x = margin.left + (peakIdx / ecgData.length) * plotWidth;
            const y =
              margin.top + plotHeight - (ecgData[peakIdx] - minVal) * scale;

            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fill();

            // Draw heart icon above peak
            ctx.font = "20px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("‚ù§Ô∏è", x, y - 15);
          }
        });
      }

      // Generate demo data if no real data available
      function generateDemoData() {
        const demoData = {
          sensorId: "patient-demo",
          chunkIndex: Math.floor(totalSamples / 360),
          samples: generateSyntheticECG(360),
          peaks: 1,
          peakIndices: [120, 300],
          bpm: 60 + Math.floor(Math.random() * 30),
          hrv: 30 + Math.floor(Math.random() * 40),
          processingTime: 1 + Math.floor(Math.random() * 3),
          arrhythmia: {
            normal: Math.random() > 0.1,
            alerts: [],
          },
        };

        updateDashboard(demoData);
      }

      function generateSyntheticECG(numSamples) {
        const ecg = [];
        for (let i = 0; i < numSamples; i++) {
          const t = i / 360;
          const heartRate = 1.2; // 72 BPM

          // P wave
          const p =
            0.1 * Math.exp(-Math.pow((t % (1 / heartRate)) - 0.15, 2) / 0.0025);

          // QRS complex
          const qrs =
            1.5 * Math.exp(-Math.pow((t % (1 / heartRate)) - 0.35, 2) / 0.0005);

          // T wave
          const tWave =
            0.3 * Math.exp(-Math.pow((t % (1 / heartRate)) - 0.55, 2) / 0.005);

          // Noise
          const noise = 0.05 * (Math.random() - 0.5);

          ecg.push(p + qrs + tWave + noise);
        }
        return ecg;
      }

      // Start WebSocket connection
      connectWebSocket();

      // Initial draw
      drawWaveform();

      // Handle window resize
      window.addEventListener("resize", () => {
        canvas.width = canvas.offsetWidth;
        drawWaveform();
      });
    </script>
  </body>
</html>
